---
title: 24夏python笔记
date: 2024-05-11 15:24:43
tags: 
    - study
categories: 
    - Study
---


## 目录
- [目录](#目录)
  - [1. `self`使用](#1-self使用)
  - [2. `def __str__(self)`函数](#2-def-__str__self函数)
  - [3. 基本类的`dir()`函数](#3-基本类的dir函数)
  - [4. 基本类的`id()`函数](#4-基本类的id函数)
  - [5. `global`关键字](#5-global关键字)
  - [6. `__mro__`函数](#6-__mro__函数)
      - [1. 定义：](#1-定义)
      - [2. 使用：](#2-使用)
  - [7. `super().方法`作用](#7-super方法作用)
  - [8. 面向对象（OOP）三大特征](#8-面向对象oop三大特征)
  - [9. 类方法](#9-类方法)
      - [1. 声明](#1-声明)
      - [2. 使用注意事项](#2-使用注意事项)
  - [10. 静态方法](#10-静态方法)
      - [1. 声明](#1-声明-1)
      - [2. 注意事项](#2-注意事项)
  - [11. 异常处理](#11-异常处理)
  - [12. 模块的导入](#12-模块的导入)
  - [13. 包（package)](#13-包package)
  - [14. 文件操作函数](#14-文件操作函数)
      - [`open()`函数](#open函数)
      - [`read()`函数](#read函数)
      - [`readline()`函数](#readline函数)
      - [`write()`函数](#write函数)
      - [`close()`函数](#close函数)
  - [15. `eval()`函数](#15-eval函数)
      - [作用：](#作用)
      - [例子：](#例子)
      - [注意事项](#注意事项)


<!-- more -->


### 1. `self`使用
- 一定要在类中的`def`后的括号中加self

### 2. `def __str__(self)`函数
- 用来定义直接输出类时输出的字符串内容，此函数要有输出！

### 3. 基本类的`dir()`函数 
- 查找一个对象的所有属性和方法  

### 4. 基本类的`id()`函数
- 函数用于获取对象的唯一标识符

### 5. `global`关键字
- 将类中的变量声明为全局变量 

### 6. `__mro__`函数
    
##### 1. 定义：
- “方法解析顺序”（Method Resolution Order）    
##### 2. 使用：
    
```
class A:
    def method(self):
        print("A method")

class B(A):
    def method(self):
        print("B method")

class C(A):
    def method(self):
        print("C method")

class D(B, C):
    pass

    
print(D.__mro__)
```
```
# 输出
(<class '__main__.D'>, <class '__main__.B'>, <class '__main__.C'>, <class '__main__.A'>, <class 'object'>)

```
### 7. `super().方法`作用
- 在类中调用父类的被重写的方法

### 8. 面向对象（OOP）三大特征
- 封装    
- 继承 
- 多态
  
### 9. 类方法
##### 1. 声明
- 需要加装饰器`@classmethod`
- 同时传入参数栏由`self`变为`cls`，不需要创建对象即可使用方法
##### 2. 使用注意事项
- 当用对象名**查询**类属性，对象内找不到，会向上查询类的属性，结果为类属性
- 当用类名**修改**类属性，会对类属性修改
- 当用对象名**修改**类属性，不会向上查找类，而是创建一个和类属性同名的对象属性，类属性不修改

### 10. 静态方法
##### 1. 声明
- 需要加装饰器`@staticmethod`
##### 2. 注意事项
- 用于不需要调用 类/实例的属性/方法的方法
- 无传入参数，也不用self

### 11. 异常处理
- 利用try和except处理异常，try中是可能出现的异常，except是出现这种异常后的操作
- 可以用一下代码来处理未知异常，并把异常名称输出
    ```
    except Exception as result:
        print("error:%s" % result)
    ```
        
- 可以创建异常对象，如一下代码，实现自己创建异常，自己抛出异常
    ```
    ex = Exception("’错误信息‘")
    raise ex
    ```
### 12. 模块的导入
- `import 模块名(文件名) as 别名`用来导入相关的整个文件，通过`模块名/别名.`的方式调用工具
- `from 模块名(文件名) import 工具名`用来导入某一模块的部分工具，此时导入后的工具<u>不需要</u>通过`模块名.`的方式，可直接使用
- `from 模块名(文件名) import *`也是导入整个模块，但是可以在不通过`模块名.`的方式直接调用全局变量，函数和类。<u>虽方便，不推荐使用</u>
- 如果你从不同的模块中导入了两个同名的函数，并且在代码中调用该函数，最后导入的那个函数会覆盖之前导入的函数。
    ###### 1. 例子如下：
    test2.py
    ```
    def hh():
        print("hh! this is test2")
    ```
    test3.py
    ```
    def hh():
        print("hh! this is test3")
    ```
    test.py
    ```
    from test3 import hh
    from test2 import hh
    hh()
    ```
    test.py运行结果：
    ```
    hh! this is test2
    ```
    ###### 2. 解决方法
    1. 使用别名，将导入的同名工具重新命名
    2. 导入整个模块，在调用时用`模块名.`的方法区分
- 模块的搜索顺序
    1. 先搜索**当前目录**，再对**系统目录**进行搜索
    2. 给文件起名不要和系统的模块文件重名
    3. python中每一个模块都有一个内置属性`__file__`可以查看模块的完整路径
    ```
    # 查看random模块的完整路径
    print(random.__file__)
    ```

- 在导入模块时，被导入文件中的可以直接执行的代码会在import执行时被直接执行
    ###### 解决方案：
    - 可以在被导入文件中利用以下代码，来进行被导入文件的功能测试，同时又不会影响到其他文件的调用
        ```
        # 导入模块
        # 定义全局变量
        # 定义类
        # 定义函数

        # 在代码的最下方
        def main():
            # 对本文件的测试代码放在这里
            pass

        # 本文件运行时执行，被调用时不执行
        if __name__ == "__main__":
            main()
        ```
    - `__name__` 的作用
        - 直接运行模块时：如果直接运行一个 Python 文件，`__name__` 变量会被设置为 "`__main__`"字符串。
        - 模块被导入时：如果一个 Python 文件被导入到另一个脚本中作为模块使用，`__name__`变量会被设置为模块的名字（不包括 .py 扩展名的文件名）
  

### 13. 包（package)
- 包时包含多个模块的特殊目录
- 包必须含有`__init__.py`这个特殊文件
- 作用时一次性导入多个模块
- `__init__.py`文件中要指定对外界提供的（包目录内的）模块列表
    ```
    # . 表示当前目录
    from . import 模块列表
    ```

### 14. 文件操作函数
##### `open()`函数
- 默认以只读方式打开文件，返回文件对象
- 打开文件的语法如下：
    `f = open("文件名", "访问方式")`
- 访问方式具体参数含义如下：
    | 访问方式 | 说明 |
    |---|---|
    | **r** | 以**只读**方式打开文件。文件的指针将会放在文件的开头，这是默认模式。如果文件不存在，抛出异常 |
    | **w** | 以**写入**方式打开文件。如果文件存在**会被覆盖**。如果文件不存在，创建新文件 |
    | **a** | 以**追加**方式打开文件。如果该文件已经存在，文件指针将会放在文件的结尾。如果文件不存在，创建新文件进行写入 |
    | **r+** | 以**读写**方式打开文件。文件的指针将会放在文件的**开头**。如果文件不存在，抛出异常 |
    | **w+** | 以**读写**方式打开文件。如果文件存在**会被覆盖**。如果文件不存在，创建新文件 |
    | **a+** | 以**读写**方式打开文件。如果该文件已经存在，文件指针将会放在文件的**结尾**。如果文件不存在，创建新文件进行写入 |

##### `read()`函数
- 当运行玩`read()`函数读取文件信息后，文件指针会移动到文件末尾，若再次调用，则读取不到任何信息
  
##### `readline()`函数
- `read()`会将文件一次性读入，如果文件过大，内存占用会非常严重，而利用`readline()`函数进行循环读入便可节省内存资源
  
##### `write()`函数
- 用来将文本写入文件
  
##### `close()`函数
- 用来释放文件占用的内存空间

### 15. `eval()`函数
##### 作用：
- 将字符串当作有效的表达式来求值 并返回计算结果
##### 例子：
-   
    ```
    # 基本的数学计算
    In [1]: eval("1 + 1")
    Out[1]: 2
    ```
-   
    ```
    # 字符串重复
    In [2]: eval('"*" * 10')
    Out[2]: '**********'
    ```
-   
    ```
    # 将字符串转换成列表
    In [3]: type(eval("[1, 2, 3, 4, 5]"))
    Out[3]: list
    ```
-   
    ```
    # 将字符串转换成字典
    In [4]: type(eval("{'name': 'xiaoming', 'age': 18}"))
    Out[4]: dict
    ```
##### 注意事项
- 不能使用`eval()`函数直接转换`input()`的结果！当输入其他系统指令时，也会将字符串转化为命令执行，对系统有很大的安全性隐患
- 程序代码
    ```
    input_str = input("请输入算术题:")
    print(eval(input_str))
    ```
- 输入：
    `__import__("os").system("rm aaa")`
- 结果会将当前目录的`aaa`文件删除，严重影响系统的安全性